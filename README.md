# 🚗 java-racingcar-concurrency
멀티스레드 + 전략 기반 자동차 경주 게임

기존 ‘java-racing-8’ 싱글스레드 자동차 경주 게임을 **멀티스레드(ExecutorService) + 동시성 제어 + 전략 기반 이동 로직**으로 확장한 프로젝트입니다.

김영한님의 **실전 자바 - 고급 1편(멀티스레드와 동시성)** 강의에서 학습한 개념들을 실제 미션에 적용해보는 것을 목표로 하였습니다.

---

# 🎯 프로젝트 목표

- 자동차 이동 로직을 **병렬 처리**하여 성능 향상 실험
- 스레드 간 공유 상태를 **동시성 안전하게 설계**
- ExecutorService 기반의 **스레드 풀 구조 구현**
- 전략(Strategy)에 따른 **차별화된 이동 로직 적용**
- 싱글 스레드 vs 멀티 스레드 **성능 비교 벤치마크**
- 실무적인 레이싱 엔진 구조로 미션 확장

---

# 🧠 주요 특징

## 1) 전략 기반 이동 시스템 (Strategy Pattern)
각 자동차는 주행 전략을 하나 선택하여 이동합니다.

### 지원 전략
- **AGGRESSIVE** - 공격적 주행 (높은 이동량, 낮은 안정성)
- **NORMAL** - 기본 전략 (균형적 이동)
- **SAFE** - 안전 주행 (높은 안정성, 낮은 이동량)

전략마다 이동 확률과 거리 정책이 다르기 때문에 자동차마다 **경쟁 방식이 달라지는 전략형 레이싱**을 구현할 수 있습니다.

---

## 2) 전략 시뮬레이션
자동차는 전략을 무작위로 선택하지 않고, **"남은 라운드 동안 어떤 전략을 쓰면 이길 확률이 가장 높은가?"** 를 계산합니다.

- 각 전략을 수백~수천 번 시뮬레이션
- 경쟁자들의 가상 이동도 함께 고려
- 세 전략의 승률을 비교
- 가장 승률이 높은 전략을 선택하여 작업

이 시뮬레이션은 **완전히 CPU 바운드 작업**이기 때문에, 멀티스레드에서 성능 향상을 체감할 수 있는 구조입니다.

---

## 3) 멀티스레드 기반 병렬 레이스 엔진
자동차 하나의 이동 작업을 하나의 **Callable Task**로 구성하여 ExecutorService스레드 풀에서 병렬로 실행합니다.

- 각 자동차 이동 -> 스레드 풀에 전달
- Future 객체로 결과 수집
- 모든 자동차 이동이 끝나면 한 라운드 종료
- 동일 로직을 싱글 스레드 / 멀티 스레드에서 각각 실행하여 성능 비교 가능

### 안정성을 위한 동시성 처리 기법
- 공유 컬렉션은 **불변 구조**로 전달
- 스레드 간 경쟁을 줄인 구조 설계
- 스레드풀 기반으로 **스레드 생성 오버헤드 최소화**

---

## 4) 성능 벤치마크 기능 제공
싱글 스레드 vs 멀티 스레드 성능을 비교하기 위한 전용 벤치마커를 제공합니다.

비교 항목:
- 동일한 자동차 수
- 동일한 라운드 수
- 동일한 전략 시뮬레이션 적용
- CPU 부하가 높은 상황에서의 성능 차이


출력 예시:
```jsx
=== Result (avg, millis) ===
Single-thread : 3120
Multi-thread : 850
// 멀티스레드가 약 3~4배 더 빠르게 수행
```

---

## 5) 성능 비교 (SingleThread vs MultiThread Benchmark)
본 프로젝트는 전략 시뮬레이션(StrategyAi)을 추가하여, 각 자동차가 매 라운드마다 내부적으로 2000회 시뮬레이션을 수행하여 최적의 전략을 결정합니다.
이는 CPU 부하가 큰 작업이며, 멀티스레드 적용 여부에 따라 성능 차이가 명확히 드러납니다.

아래는 동일 조건에서 실행한 벤치마크 결과입니다.

---
### 🧪 벤치마크 환경

| 항목            | 값                           |
| ------------- | --------------------------- |
| CPU           | AMD 라이젠 7 5700U (8코어 16스레드) |
| 자동차 수         | **24대**                     |
| 라운드 수(시도 횟수)  | **100회**                    |
| 전략 시뮬레이션 횟수   | **2000회**                   |
| ThreadPool 크기 | **8 threads (코어 수 기준)**     |
| 테스트 반복        | Warmup 3회 + 측정 5회 평균        |

---
### 📊 벤치마크 결과

```jsx
=== Result (avg, millis) ===
Single-thread : 4445 ms
Multi-thread  : 2830 ms
```

🔍 해석
- 멀티스레드는 동일한 전략 계산 작업을 **여러 스레드에 분산**하여 수행한다.
- 싱글 스레드는 각 자동차 x 100번 라운드 x 각 라운드마다 2000번 시뮬레이션을 **순차적으로 연산**한다.
- 실제로 멀티스레드는 **약 1.57배 (44% 성능 개선)** 빠르게 수행되었다.

---
### 🔥 Extreme 모드 벤치마크
멀티스레드 효과를 극대화하기 위해 다음과 같은 입력으로 벤치마크를 수행했습니다.

- 자동차 수: 32대
- 라운드 수: 150회
- 전략 시뮬레이션 횟수: 5000회
- 스레드 풀: **환경에 따라 다르게 설정**
- Warmup 3회 + 측정 5회 평균

1) **Intel i5-10210U, 4C/8T, FixedThreadPool(8)**

```jsx
=== Result (avg, millis) ===
Single-thread : 33512 ms
Multi-thread  : 18083 ms
```

- **약 1.85배 성능 향상**
- 실행 시간이 **46% 단축**

2) **Ryzen 7 9700X, 8C/16T, FixedThreadPool(16)**

```jsx
=== Result (avg, millis) ===
Single-thread : 22234 ms
Multi-thread  : 3117 ms
```

- 약 **7.1배 성능 향상**
- 실행 시간이 **86% 이상 단축**

---
### 🖥 환경에 따른 성능 차이
같은 코드, 같은 입력값에서 **실행 환경(CPU,코어 수)** 에 따라 멀티스레드의 효과가 얼마나 달라지는지 확인하기 위해 노트북과 데스크탑에서 동일한 벤치마크를 돌려보았습니다.

| 구분            | 노트북                     | 데스크탑                        |
| ------------- | ----------------------- | --------------------------- |
| CPU           | Intel i5-10210U (4코어 8스레드) | AMD Ryzen 7 9700X (8코어 16스레드) |
| 스레드 풀 크기      | 8 threads               | 16 threads                  |
| 자동차 수         | 32대                     | 32대                         |
| 라운드 수         | 150회                    | 150회                        |
| 전략 시뮬레이션 횟수   | 5000회                   | 5000회                       |
| Single-thread | 33,512 ms               | 22,234 ms                   |
| Multi-thread  | 18,083 ms               | 3,117 ms                    |
| 멀티스레드 속도 향상   | 약 1.85배                 | 약 7.1배                      |

- 같은 멀티스레드 코드라도
    - "코어 수가 적고 저전력인 노트북에서는 **효과가 제한적**이었고,"
    - "고클럭,다코어 데스크탑에서는 **극적인 성능 향상**이 나타났습니다."
- **"멀티스레드는 설계 + 하드웨어 환경을 함께 봐야 한다"** 는 점을 알 수 있습니다.

---

# 🏎 기본 게임 규칙

- 사용자로부터 자동차 이름 입력 (쉼표로 구분, 각 이름은 5자 이하)
- 사용자로부터 이동 횟수 입력
- 각 라운드마다 모든 자동차는 자신의 **전략 확률에 따라 이동**
- 라운드별 실행 결과 출력
- 최종 위치가 가장 먼 자동차가 우승

---

# ❗입력 검증

다음 조건 위반 시 ‘IllegalArgumentException’ 발생 후 종료됩니다.

- 이름이 5자 초과
- 자동차가 1대만 입력된 경우
- 빈 토큰 포함 (예: `",pobi,jun"`, `"pobi,,jun"`)
- 공백 또는 빈 문자열 입력
- 시도 횟수가 숫자가 아닌 경우
- 시도 횟수가 0 이하

---

# ⚠ 예외 처리 & 종료 전략

**사용자 입력 오류**와 **시스템/개발자 오류**를 구분해서 처리합니다.

## 1) 사용자 입력 오류 (입력 검증 실패)
사용자가 잘못된 값을 입력한 경우는 **복구 불가능한 비즈니스 예외**로 보고, `IllegalArgumentException`으로 처리한 뒤 **[ERROR]메시지를 출력하고 종료**합니다.

---
## 2) 멀티스레드 내부 예외 (개발자 수정 대상)
멀티스레드 실행(`ExecutorService`, `invokeAll`, `Future.get()` 등)과정에서 발생하는 예외는 **개발자가 수정해야 하는 버그/시스템 예외**로 보고, 별도 처리하지 않고 **그대로 터뜨립니다.**

---
## 3) ExecutorService 우아한 종료 (Graceful Shutdown)
예외 발생 여부와 관계 없이, **스레드 풀은 항상 안전하게 종료**되도록 설계했습니다.
- **정상 종료 시도** -> 일정 시간 동안 기존 작업이 끝나길 기다림
- **시간 초과 시 강제 종료** -> `shutdownNow()`로 인터럽트 전파
- 그래도 안 되면 로그를 남기고 종료 (디버깅 포인트)

---

# 🏁 요약

- 단순한 자동차 경주가 아니라 **전략 기반 + 멀티스레드 병렬 처리 + 동시성 안전 설계**가 결합된 개선 버전입니다.
- 학습한 멀티스레드/동시성 개념을 도메인에 자연스럽게 적용했습니다.
- 복잡도가 증가하면서 “싱글 스레드 vs 멀티 스레드 성능 차이”를 실제로 관찰할 수 있습니다.