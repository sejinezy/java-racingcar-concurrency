# 🚗 java-racingcar-concurrency
멀티스레드 + 전략 기반 자동차 경주 게임

이 프로젝트는 기존 ‘java-racing-8’ 싱글스레드 자동차 경주 게임을 **멀티스레드(ExecutorService) + 동시성 제어 + 전략 기반 이동 로직**으로 확장한 구현입니다.

김영한님의 **실전 자바 - 고급 1편(멀티스레드와 동시성)**강의에서 학습한 개념들을 실제 미션에 적용해보는 것을 목표로 하였습니다.

---

# 🎯 프로젝트 목표

- 자동차 이동 로직을 **병렬 처리**하여 성능 향상 실험
- 스레드 간 공유 상태를 **동시성 안전하게 설계**
- ExecutorService 기반의 **스레드 풀 구조 구현**
- 전략(Strategy)에 따른 **차별화된 이동 로직 적용**
- 싱글 스레드 vs 멀티 스레드 **성능 비교 벤치마크**
- 실무적인 레이싱 엔진 구조로 미션 확장

---

# 🧠 주요 특징

## 1) 전략 기반 이동 시스템 (Strategy Pattern)
각 자동차는 주행 전략을 하나 선택하여 이동합니다.

### 지원 전략
- **AGGRESSIVE** - 공격적 주행 (높은 이동량, 낮은 안정성)
- **NORMAL** - 기본 전략 (균형적 이동)
- **SAFE** - 안전 주행 (높은 안정성, 낮은 이동량)

전략마다 이동 확률과 거리 정책이 다르기 때문에 자동차마다 **경쟁 방식이 달라지는 전략형 레이싱**을 구현할 수 있습니다.

---

## 2) 전략 시뮬레이션
자동차는 “남은 라운드”를 가상 시뮬레이션하여 각 전략의 승률을 계산하고 **가장 유리한 전략을 자동 선택**할 수 있습니다.

이 기능은 CPU 연산량이 크기 때문에 싱글 스레드와 멀티 스레드 성능이 극명하게 갈립니다.

---

## 3) 멀티스레드 기반 병렬 레이스 엔진
- 각 자동차의 이동 작업을 태스크로 분리
- ExecutorService의 스레드 풀에서 병렬 실행
- Future 기반 결과 수집
- 라운드마다 모든 자동차 이동을 병렬 처리하여 속도 향상

---

## 4) 성능 벤치마크 기능 제공
싱글 스레드 vs 멀티 스레드 성능을 비교하기 위한 전용 벤치마커를 제공합니다.

비교 항목:
- 동일한 자동차 수
- 동일한 라운드 수
- 동일한 전략 시뮬레이션 적용
- CPU 부하가 높은 상황에서의 성능 차이

출력 예시:
```jsx
=== Result (avg, millis) ===
Single-thread : 3120
Multi-thread : 850
// 멀티스레드가 약 3~4배 더 빠르게 수행
```

---

# 🏎 기본 게임 규칙

- 사용자로부터 자동차 이름 입력 (쉼표로 구분, 각 이름은 5자 이하)
- 사용자로부터 이동 횟수 입력
- 각 라운드마다 모든 자동차는 자신의 **전략 확률에 따라 이동**
- 라운드별 실행 결과 출력
- 최종 위치가 가장 먼 자동차가 우승

---

# ❗입력 검증

다음 조건 위반 시 ‘IllegalArgumentException’ 발생 후 종료됩니다.

- 이름이 5자 초과
- 자동차가 1대만 입력된 경우
- 빈 토큰 포함 (예: `",pobi,jun"`, `"pobi,,jun"`)
- 공백 또는 빈 문자열 입력
- 시도 횟수가 숫자가 아닌 경우
- 시도 횟수가 0 이하

---

# 🏁 요약

- 단순한 자동차 경주가 아니라 **전략 기반 + 멀티스레드 병렬 처리 + 동시성 안전 설계**가 결합된 개선 버전입니다.
- 학습한 멀티스레드/동시성 개념을 도메인에 자연스럽게 적용했습니다.
- 복잡도가 증가하면서 “싱글 스레드 vs 멀티 스레드 성능 차이”를 실제로 관찰할 수 있습니다.